---
title: "Handling Quality Control Flags and Adjusted Data"
author: "Jaimie Harbin (https://orcid.org/0000-0003-3774-3732), Dan Kelley (https://orcid.org/0000-0001-7808-5911) and Clark Richards (https://orcid.org/0000-0002-7833-206X)"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_vignette:
    toc: true
    number_sections: true
    fig_caption: yes
    fig_width: 5
    fig_height: 5
    dpi: 72
    dev.args: list(pointsize=11)
vignette: >
  %\VignetteIndexEntry{Handling Quality Control Flags and Adjusted Data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}?
---

```{r, echo=FALSE}
knitr::opts_chunk$set(collapse=TRUE, comment="#>")
```

**Abstract**
Argo floats data undergo a series of testing procedures to assess the quality.
In addition, some data sets undergo adjustments that are made in recognition of
the Quality Control (QC) analysis or to employ information about improved
calibrations, etc. The creators of `argoFloats` therefore developed a way to
deal with QC flags and adjusted data. For quality control, this centers around
three functions: `plot(which='QC')`, `showQCTests()`and `applyQC()`. Adjusted
data are handled with the `useAdjusted()` function.

# How QC Flags are set

Core, biogeochemical (BGC), and Deep Argo data all undergo testing to ensure the
data found at the Data Assembly Centers are as accurate as possible. This is
done on both "real time" data and "delayed mode" data. As explained in the Argo
User's Manual (Carval et al. 2019), real time measurements are assigned a QC
flag within a 24-48 hour time frame, and delayed mode are looked at by
scientists who apply procedures to check the quality.

# Flags

As described by the Argo user's manual (Carval et al. 2019), data that are given
a flag value of 1, 2, 5, or 8 are considered 'good' data. If data are given a
flag value of 9 (or missing value) they are not used, and flags 3, 5, 6, and 7
are considered 'bad' data.

`argoFloats` has taken this idea, and has incorporated a 3 step process when
considering the QC of Argo floats. The three step process encourages
users to always analyze the data they are considering, and acknowledges that the
user assumes all risk from their Argo data, as described in section 1.3 of the
Argo User's Manual (Carval et al. 2019). The three step process is shown in the following diagram.

![Figure 1: argoFloats Quality Control Flag Process](qc_flowchart.png)

This vignette will walk the users through the three step flag process using the float with `id` 1901584 near the Bahamas.

### Step One: QC Plot

Our `argoFloats` package uses the flags of profiles to distinguish between "good" and
"bad" data. Based on this, we created a plot type to display the quality of data, the `QC`
plot. The `QC` plot is a two panel plot that shows parameter quality and
parameter mean. This only works if `x` is an object that was created by
`getProfiles()` and the user provides the `parameter` of interest. If the
user is uncertain about what parameters exist within a certain cycle,
`argoFloats` will prompt the user with the appropriate parameters.

An example of how to get the `QC` plot for temperature for the float with `id` 1901584 is as follows:

```{r, warning=FALSE, error=FALSE, message=FALSE, eval=FALSE}
library(argoFloats)
data("index")
index1 <- subset(index, id='1901584')
profiles <- getProfiles(index1)
argos <- readProfiles(profiles)
plot(argos, which='QC', parameter='temperature')
```

![Figure 2: QC plot for temperature recorded by the float with `id` 1901584](plotqc.png)


**Exercise 1:** Use the previous code to determine the QC of temperature for
float `id` 4900845 in synthetic data. Explain your results.

### Step Two: showQCTests()

`showQCTests` prints a summary of the QC tests (if any) that were
performed on an Argo cycle. It uses `hexToBits()` to decode the hexadecimal
values that may be stored in `historyQCTest`. From there it pairs the determined test values with the appropriate action, QC Tests performed or QC Tests failed, found in `historyAction` within the metadata
slot of an individual Argo profile, as read directly with `oce::read.argo()` or
indirectly with `readProfiles()`.

Using the same example as shown in `plot(..., which='QC')`, an example of 
`showQCTests()` is shown below:

```{r, message=FALSE, error=FALSE, warning=FALSE, eval=FALSE}
library(argoFloats)
data('index')
index1 <- subset(index, id='1901584')
index2 <- subset(index1, cycle='124') 
profiles2 <- getProfiles(index2)
argos2 <- readProfiles(profiles2)
showQCTests(argos2[[1]])
```

In section 3.11 Reference table 11: QC test binary ids of the Argo User's Manual
(Carval et al. 2019), we see that test 14 was failed: ie. the Density Inversion Test.

**Exercise 2**: Use the first cycle of Argo float with `id` 4900845 in exercise one to determine which tests were performed and/or failed during quality control testing. Explain your results.

### Step Three: applyQC()

The `applyQC()` function examines QC within an `argoFloats` object that was
created by `readProfiles()`. By default, it replaces all suspicious data with NA
values, so they will not appear in plots or be considered in calculations. This
is an important early step in processing, because suspicious Argo floats
commonly report data that are suspicious based on statistical and physical
measures.

Using the same example as shown in `plot(...,which='QC')` and `showQCTests()`, the below example demonstrates the significance of `applyQC` with a TS diagram.

```{r, message=FALSE, error=FALSE, warning=FALSE, eval=FALSE}
library(argoFloats)
# Contrast TS diagrams for raw and flag-handled data
data(index)
index1 <- subset(index, id='1901584')
argos <- readProfiles(getProfiles(index1))
clean <- applyQC(argos)
par(mfrow=c(1, 2))
plot(argos, which="TS")
plot(clean, which="TS")
```

![Figure 3: argoFloats applyQC() function used on float with `id` 1901584](applyQC.png)


**Exercise 3** : Use `applyQC()` on float `id` with 4900845 and plot comparing TS diagrams. Explain your results.

**NOTE:** Although, the `applyQC` function removes the "bad" data for the user, if they wish to analyze the data themselves, one easy way using basic R functions is as follows:

```{r, eval=FALSE}
library(argoFloats)
data(index)
index1 <- subset(index, id='1901584')
argos <- readProfiles(getProfiles(index))
A <- argos[[1]]
D <- data.frame(T = A[['temperature']], TF=A[['temperatureFlag']], S=A[['salinity']], SF=A[['salinityFlag']], P=A[['pressure']], PF=A[['pressureFlag']])
head(D)
```
# Adjusted Data

### useAdjusted()

Some data sets undergo adjustments that are made in recognition of the Quality
Control (QC) analysis or improved calibrations. These type of data sets are
considered "adjusted" and are handled using `useAdjusted()`. `useAdjusted()` is done by using
`oce::preferAdjusted()` on each of the Argo objects stored within the first
argument. The procedure is fairly complicated, so users are urged to read the
documentation for `oce::preferAdjusted()` after reading the sketch provided in
the “Details” section of `?useAdjusted()` and familiarizing themselves with the
flow chart below that demonstrates the steps taken when a user specifies
`which=ALL` or `which=<param>`.

![Figure 4: Flow chat for useAdjusted() function within argoFloats package when which argument is equal to ALL or param](../man/figures/useAdjustedDiagram.png)

An example of the significance of adjusted data can be shown below:

```{r, warning=FALSE, error=FALSE, message=FALSE, eval=FALSE}
library(argoFloats)
raw <- readProfiles(system.file("extdata", "SD5903586_001.nc", package="argoFloats"))
adj <- useAdjusted(raw)
par(mfrow=c(1,2), mar=c(5,4,1,2))
hist(raw[[1]][['oxygen']], xlab='Raw Oxygen', ylab="Frequency", main=NULL)
hist(adj[[1]][['oxygen']], xlab='Adjusted Oxygen', ylab="Frequency", main=NULL)
summary(unlist(raw[['oxygen']]))
summary(unlist(adj[['oxygen']]))
```

![Figure 5: argoFloats useAdjusted() function used on float with `id` 1901584](useAdjusted.png)


**Exercise 4** Use `useAdjusted()` on the float with `id` 5903586, cycle=50 to
compare adjusted to raw data.

# Answers

**Exercise 1:** Use the previous code to determine the QC of temperature for
float `id` 4900845 in synthetic data. Explain your results.
```
library(argoFloats)
data('indexSynthetic')
sub <- subset(indexSynthetic, id='4900845')
profiles <- getProfiles(sub)
argos <- readProfiles(profiles)
plot(argos, which='QC', parameter='temperature')
```
As shown in the plot, 100% of the temperature data is considered "good". This
implies to the user that all data is considered okay to use.

**Exercise 2**: Use the first cycle of Argo float with `id` 4900845 in exercise one to determine which tests were performed and/or failed during quality control testing. Explain your results.

```
library(argoFloats)
data('indexSynthetic')
sub <- subset(indexSynthetic, id='4900845')
profiles <- getProfiles(sub)
argos <- readProfiles(profiles)
a1 <- argos[[1]]
showQCTests(a1)
```
As shown by the `showQCTests()` function, `historyAction` is not present in the metadata for this cycle, so no report can be given. This is a case where the user would have to self analyze their data to ensure all data seems reasonable.

**Exercise 3** : Use `applyQC()` on float `id` with 4900845 and plot comparing TS diagrams. Explain your results.
```
library(argoFloats)
# Contrast TS diagrams for raw and flag-handled data
data(indexSynthetic)
sub <- subset(indexSynthetic, id='4900845')
profiles <- readProfiles(getProfiles(sub))
clean <- applyQC(profiles)
par(mfrow=c(1, 2))
plot(profiles, which="TS")
plot(clean, which="TS")
```
As shown by the plot, the plot containing "good" data and the plot containing "bad" data are the same. This indicates no "bad" data were taken away, and it is up to the user to determine the validy of the data.

**Exercise 4** Use `useAdjusted()` on the float with `id` 5903586, cycle=50 to
compare adjusted to raw data.

```
library(argoFloats)
bai <- getIndex('synthetic')
s <- subset(bai, id='5903586')
ss <- subset(s, 50)
profiles <- getProfiles(ss)
raw <- readProfiles(profiles)
adj <- useAdjusted(raw)
par(mfrow=c(1, 2))
oce::plotProfile(oce::as.ctd(raw[[1]]), xtype="oxygen")
mtext("Raw data", side=3, line=-1, col=2)
oce::plotProfile(oce::as.ctd(adj[[1]]), xtype="oxygen")
mtext("Adjusted data", side=3, line=-1, col=2)
summary(unlist(raw[['oxygen']]))
summary(unlist(adj[['oxygen']]))
```
There are no adjustments. This is a case where a use must analyze their data to determine if it is "good" data.

# References

1. Carval, Thierry, Bob Keeley, Yasushi Takatsuki, Takashi Yoshida, Stephen Loch Loch, Claudia Schmid, and Roger Goldsmith. Argo User's Manual V3.3. Ifremer, 2019. https://doi.org/10.13155/29825.
