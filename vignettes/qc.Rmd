---
title: "Handling Quality Control Flags and Adjusted Data"
author: "Jaimie Harbin (https://orcid.org/0000-0003-3774-3732), Dan Kelley (https://orcid.org/0000-0001-7808-5911) and Clark Richards (https://orcid.org/0000-0002-7833-206X)"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_vignette:
    toc: true
    number_sections: true
    fig_caption: yes
    fig_width: 5
    fig_height: 5
    dpi: 72
    dev.args: list(pointsize=11)
vignette: >
  %\VignetteIndexEntry{Handling Quality Control Flags and Adjusted Data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}?
---

```{r, echo=FALSE}
knitr::opts_chunk$set(collapse=TRUE, comment="#>")
```

**Abstract**
Argo floats data undergo a series of testing procedures to assess the quality.
In addition, some data sets undergo adjustments that are made in recognition of
the Quality Control (QC) analysis or to employ information about improved
calibrations, etc. The creators of `argoFloats` therefore developed a way to
deal with QC flags and adjusted data. For quality control, this centers around
three functions: `plot(which='QC')`, `showQCTests()`and `applyQC()`. Adjusted
data are handled with the `useAdjusted()` function.

# How QC Flags are set

Core, biogeochemical (BGC), and Deep Argo data all undergo testing to ensure the
data found at the Data Assembly Centers are as accurate as possible. This is
done on both "real time" data and "delayed mode" data. As explained in the Argo
User's Manual (Carval et al. 2019), real time measurements are assigned a QC
flag within a 24-48 hour time frame, and delayed mode are looked at by
scientists who apply procedures to check the quality.

# Flags

As described by the Argo user's manual (Carval et al. 2019), data that are given
a flag value of 1, 2, 5, or 8 are considered 'good' data. If data are given a
flag value of 9 (or missing value) they are not used, and flags 3, 5, 6, and 7
are considered 'bad' data.

`argoFloats` has taken this idea, and has incorporated a 3 step process when
considering the QC of Argo floats. The three step process encourages
users to always analyze the data they are considering, and acknowledges that the
user assumes all risk from their Argo data, as described in section 1.3 of the
Argo User's Manual (Carval et al. 2019). The three step process is shown in the following diagram.

![Figure 1: argoFloats Quality Control Flag Process.](qc_flowchart.png)

This vignette will walk the users through the three step flag process while
demonstrating examples using the float with `id` 1901584 near the Bahamas.

### Step One: QC Plot

Our `argoFloats` package uses the flags of profiles to distinguish between "good" and
"bad" data. Based on this, we created a plot type to display the quality of data, the `QC`
plot. The `QC` plot is a two panel plot that shows parameter quality and
parameter mean. This only works if `x` is an object that was created by
`getProfiles()` and the user provides the `parameter` of interest. If the
user is uncertain about what parameters exist within a certain cycle,
`argoFloats` will prompt the user with the appropriate parameters.

An example of how to get the `QC` plot for temperature for the float with `id` 1901584 is as follows:

```{r, warning=FALSE, error=FALSE, message=FALSE, eval=FALSE}
library(argoFloats)
data("index")
index1 <- subset(index, id='1901584')
profiles <- getProfiles(index1)
argos <- readProfiles(profiles)
plot(argos, which='QC', parameter='temperature')
```

![Figure 2: QC plot for temperature recorded by the float with `id` 1901584.](plotqc.png)

As shown by the above plot, both "good" and "bad" data exist within this
subsection of float `id` 1901584. For example, the first cycle is condsidered
"bad", as shown by the red dot. If the user had the desire to investigate the QC
performed on this data, the next step would be to use the `showQCTests` function.


**Exercise 1:** Use the previous code to determine the QC of temperature for
float `id` 4900845 in synthetic data. Explain your results.

### Step Two: showQCTests()

`showQCTests` prints a summary of the QC tests (if any) that were performed on
an Argo cycle. It uses `hexToBits()` to decode the hexadecimal values that may
be stored in `historyQCTest`. From there it pairs the determined test values
with the appropriate actions, QC Tests performed or QC Tests failed, found in
`historyAction` within the metadata slot of an individual Argo profile, as read
directly with `oce::read.argo()` or indirectly with `readProfiles()`.

To analyze the first cycle shown by the `plot(..., which='QC')` example, we will
use previously defined variables and the `showQCTests()` function as shown below.

```{r, message=FALSE, error=FALSE, warning=FALSE, eval=FALSE}
index2 <- subset(index1, cycle='124') 
profiles2 <- getProfiles(index2)
argos2 <- readProfiles(profiles2)
showQCTests(argos2[[1]])
```

As shown by the output of this function,

```
Tests performed: 2 3 4 5 6 13 14 15 16 17 19
    Failed test 14 (Density Inversion test)
```

Test 14, the Density Inversion Test was failed, given in section 3.11 Reference
table 11: QC test binary ids of the Argo User's Manual (Carval et al. 2019).

At this step, it is recommended that the user utilizes the Argo Quality Control
Manual for CTD and Trajectory Data (Wong et al. 2020) to determine the critera
necessary to fail this test, and the action taken if this test is failed. This
will help the user determine if they agree with the results or not. A good way
of doing this is by using the following code to analyze the flags of specific
parameters:

```{r, eval=FALSE}
A <- argos[[1]]
D <- data.frame(T = A[['temperature']], TF=A[['temperatureFlag']], S=A[['salinity']], SF=A[['salinityFlag']], P=A[['pressure']], PF=A[['pressureFlag']])
```


**FIXME** IN THIS CASE THE PROFILE DOES FOLLOW THE ACTIONS IF THE TEST IS FAILED
and we will therefore move on to the next step, `applyQC`.

**Exercise 2**: Use the first cycle of Argo float with `id` 4900845 in exercise
one to determine which tests were performed and/or failed during quality control
testing. Explain your results.

### Step Three: applyQC()

The `applyQC()` function examines QC within an `argoFloats` object that was
created by `readProfiles()`. By default, it replaces all suspicious data with NA
values, so they will not appear in plots or be considered in calculations. This
is an important early step in processing, because suspicious Argo floats
commonly report data that are suspicious based on statistical and physical
measures.

If the user decides they are in agreement with the QC tests performed, and
solely want to work with the data that is considered "good", they can use the
`applyQC` function to rid the "bad" data. An example of where this could be
useful is when looking at TS diagrams as shown below:

```{r, message=FALSE, error=FALSE, warning=FALSE, eval=FALSE}
clean <- applyQC(argos)
par(mfrow=c(1, 2))
plot(argos, which="TS")
plot(clean, which="TS")
```

![Figure 3: argoFloats applyQC() function used on float with `id` 1901584.](applyQC.png)


**Exercise 3** : Use `applyQC()` on float `id` with 4900845 and plot comparing
TS diagrams. Explain your results.

# Adjusted Data

### useAdjusted()

Some data sets undergo adjustments that are made in recognition of the Quality
Control (QC) analysis or improved calibrations. These type of data sets are
considered "adjusted" and are handled using `useAdjusted()`. `useAdjusted()` is done by using
`oce::preferAdjusted()` on each of the Argo objects stored within the first
argument. The procedure is fairly complicated, so users are urged to read the
documentation for `oce::preferAdjusted()` after reading the sketch provided in
the “Details” section of `?useAdjusted()` and familiarizing themselves with the
flow chart below that demonstrates the steps taken when a user specifies
`which=ALL` or `which=<param>`.

![Figure 4: Flow chat for useAdjusted() function within argoFloats package when which argument is equal to ALL or param.](../man/figures/useAdjustedDiagram.png)

One example where it is useful to use adjusted data is when considering oxygen. Often times, BCG sensors have calibration issues and more specifically for oxygen optodes, floats can initially read low compared to climatology. 



**FIXME:** 'significance' above is an overly vague word, and it will remind
readers of statistical significance, which this is not.  I think we need a
short paragraph here, explaining what the code is going to do.  Some points to
touch on: (a) using built-in dataset named X, (b) focussing on first cycle,
etc.  And, after, we should have a paragraph that tells the p value of the
regression, etc.

```{r, warning=FALSE, error=FALSE, message=FALSE, fig.cap="*Figure 5.* Comparison of raw and adjusted oxygen for built-in float file `SD5903586_001.nc`.  The dotted line is a 1:1 relationship, and the red line is the result of linear regression (see text)."}
library(argoFloats)
raw <- readProfiles(system.file("extdata", "SD5903586_001.nc", package="argoFloats"))
adj <- useAdjusted(raw)
# Focus on oxygen in the first cycle
rawOxygen <- raw[[1]][["oxygen"]]
adjOxygen <- adj[[1]][["oxygen"]]
plot(rawOxygen, adjOxygen,
     xlab=expression("Raw Oxygen ["*mu*mol/kg*"]"),
     ylab=expression("Adjusted Oxygen ["*mu*mol/kg*"]"))
abline(0, 1, lty=3)
model <- lm(adjOxygen ~ rawOxygen)
abline(model, col=2)
```

**FIXME: next few lines are some rough text to show JH how we can grab
regression results. Note that we can only use the results of a regression after
the fact, so we cannot show things like I'm showing in text above a figure.**

The mean absolute residual of the linear regression between adjusted and raw
oxygen concentrations is $`r round(mean(abs((model$residuals))),8)`$
$\mu$mol/kg, suggesting that the adjustment amounted to a simple linear
transform.



**FIXME: Some changes/notes by DK:**

* The title of the following exercise makes it look just like the example
above.  We need always to inform the reader of what's going on, and where they
are in their journey.  This is what I call ``glue'' text.


**Exercise 4** Use `useAdjusted()` on the float with `id` 5903586, cycle=50 to
compare adjusted to raw data.

**FIXME: question from DK:**

The solution says there are no adjustments, but I think there *are* adjustments, e.g. the `summary()` calls reveal
as follows:
```
 summary(unlist(raw[['oxygen']]))
    Min.  1st Qu.   Median     Mean  3rd Qu.     Max.     NA's 
  0.0555   0.5035   0.9494  50.1615 115.6693 176.6477      487 
> summary(unlist(adj[['oxygen']]))
    Min.  1st Qu.   Median     Mean  3rd Qu.     Max.     NA's 
  0.0643   0.5841   1.1013  58.1873 134.1763 204.9114      487 
```

# Answers

**Exercise 1:** Use the previous code to determine the QC of temperature for
float `id` 4900845 in synthetic data. Explain your results.
```
library(argoFloats)
data('indexSynthetic')
sub <- subset(indexSynthetic, id='4900845')
profiles <- getProfiles(sub)
argos <- readProfiles(profiles)
plot(argos, which='QC', parameter='temperature')
```
As shown in the plot, 100% of the temperature data is considered "good". This
implies to the user that all data is considered okay to use.

**Exercise 2**: Use the first cycle of Argo float with `id` 4900845 in exercise one to determine which tests were performed and/or failed during quality control testing. Explain your results.

```
library(argoFloats)
data('indexSynthetic')
sub <- subset(indexSynthetic, id='4900845')
profiles <- getProfiles(sub)
argos <- readProfiles(profiles)
a1 <- argos[[1]]
showQCTests(a1)
```
As shown by the `showQCTests()` function, `historyAction` is not present in the metadata for this cycle, so no report can be given. This is a case where the user would have to self analyze their data to ensure all data seems reasonable.

**Exercise 3** : Use `applyQC()` on float `id` with 4900845 and plot comparing TS diagrams. Explain your results.
```
library(argoFloats)
# Contrast TS diagrams for raw and flag-handled data
data(indexSynthetic)
sub <- subset(indexSynthetic, id='4900845')
profiles <- readProfiles(getProfiles(sub))
clean <- applyQC(profiles)
par(mfrow=c(1, 2))
plot(profiles, which="TS")
plot(clean, which="TS")
```
As shown by the plot, the plot containing "good" data and the plot containing "bad" data are the same. This indicates no "bad" data were taken away, and it is up to the user to determine the validy of the data.

**Exercise 4** Use `useAdjusted()` on the float with `id` 5903586, cycle=50 to
compare adjusted to raw data.

```
library(argoFloats)
bai <- getIndex('synthetic')
s <- subset(bai, id='5903586')
ss <- subset(s, 50)
profiles <- getProfiles(ss)
raw <- readProfiles(profiles)
adj <- useAdjusted(raw)
par(mfrow=c(1, 2))
oce::plotProfile(oce::as.ctd(raw[[1]]), xtype="oxygen")
mtext("Raw data", side=3, line=-1, col=2)
oce::plotProfile(oce::as.ctd(adj[[1]]), xtype="oxygen")
mtext("Adjusted data", side=3, line=-1, col=2)
summary(unlist(raw[['oxygen']]))
summary(unlist(adj[['oxygen']]))
```
The result of the `summary()` calls is as follows.
```
            Min.          1st Qu.           Median             Mean 
  0.055451575667   0.503543332219   0.949396371841  50.161460198152 
         3rd Qu.             Max.             NA's 
115.669265747070 176.647735595703              487 
> summary(unlist(adj[['oxygen']]))
            Min.          1st Qu.           Median             Mean 
  0.064323827624   0.584110274911   1.101299762726  58.187292793021 
         3rd Qu.             Max.             NA's 
134.176345825195 204.911361694336              487 
```

# References

1. Carval, Thierry, Bob Keeley, Yasushi Takatsuki, Takashi Yoshida, Stephen Loch Loch, Claudia Schmid, and Roger Goldsmith. Argo User's Manual V3.3. Ifremer, 2019. https://doi.org/10.13155/29825.

2. Wong, Annie, Robert Keeley, Thierry Carval, and Argo Data Management Team. “Argo Quality Control Manual for CTD and Trajectory Data,” January 1, 2020. https://archimer.ifremer.fr/doc/00228/33951/.
