---
title: "Introduction to argoFloats Quality Control"
author: "Dan Kelley (https://orcid.org/0000-0001-7808-5911) and Jaimie Harbin (https://orcid.org/0000-0003-3774-3732)"
date: "`r Sys.Date()`"
---

**Abstract**

# Introduction to Flags
Core, biogeochemical (BGC), and Deep Argo data all undergo testing to ensure the data found at the Data Assembly Centers are as accurate as possible. More specifically, testing is done in three levels:

1: Real time that complete checks on all measurements and assigned a quality flag within a 24-48 hour timeframe
2. Delayed mode
3. Regional scientific analyses of all float data with other available data. The procedures for regional analyses are still to be determined.

*Hypothesis* : Our hypothesis is that real-time data have all NAs for <PARAM>ADJUSTED, and we should therefore only use the <PARAM>ADJUSTED for delayed mode data.

# Flags
As described by the Argo userâ€™s manual V3.3 [1], data that are given a flag value of 1, 2, 5, or 8 are considered 'good' data. If data are given a flag value of 9 (or missing value) they are not used, and flags 3, 5, 6, and 7 are considered 'bad' data.

`argoFloats` has taken this idea, and has incorporated a 3 step process when considering the quality control of Argo data. The three step process encourages users to always analyze the data they are considering. The three step process is as follows:

```{r qualityControlProcess, echo=FALSE, fig.cap="Figure 1: Work flow of the argoFloats package.", fig.height=2.8, fig.width=5, fig.align='center', dev.args=list(pointsize=10), warning=FALSE}
colText <- "darkblue"
colCode <- "black"
library(graphics)
textInBox <- function(x, y, text, cex=1, pos=4, center=TRUE, family="Times New Roman", col="black", tweakx=0)
{
    w <- graphics::strwidth(text)
    h <- graphics::strheight(text)
    if (center)
        x <- x - w/2
    text(x+tweakx, y, text, cex=cex, pos=pos, family=family, col=col)
    rect(x+tweakx, y-h, x+tweakx+1.1*w, y+h, border=col)
    invisible(list(w=w, h=h))
}
omar <- par("mar")
par(mar=c(0,1,0,0))
plot(c(0, 1), c(0, 1), type="n", xlab="", ylab="", axes=FALSE)
x0 <- 0.25
y0 <- 0.9
dy <- 0.2
wh <- textInBox(x0, y0, "What is the quality of the data?", col=colText)
h <- wh$h * 1.2
xarrow <- x0 + 0.01 # not sure why we need to move it
arrows(xarrow, y0-h, xarrow, y0-dy+h, length=0.1, col=colText)
y0 <- y0 - dy
textInBox(x0, y0, "Why is the quality like this?", col=colText)
arrows(xarrow, y0-h, xarrow, y0-dy+h, length=0.1, col=colText)
y0 <- y0 - dy
textInBox(x0, y0, "Do I agree with the quality control?", col=colText)
x0 <- 0.8
y0 <- 0.9
wh <- textInBox(x0, y0, "plot(which='QC') ", family="sans", col=colCode)
h <- wh$h * 1.2
xarrow <- x0 + 0.01 # not sure why we need to move it
arrows(xarrow, y0-h, xarrow, y0-dy+h, length=0.1)
y0 <- y0 - dy
textInBox(x0, y0, "showQCTests() ", family="sans", col=colCode)
arrows(xarrow, y0-h, xarrow, y0-dy+h, length=0.1)
y0 <- y0 - dy
textInBox(x0, y0, "applyQC() ", family="sans", col=colCode)
par(mar=omar)
```

## QC Plot
Our `argoFloats` package uses the flags of profiles to determine "good" and "bad" data. We then created a plot type to demonstrate the quality of data, the `QC` plot. The QC plot is a plot of parameter quality and parameter mean. This only works if `x` is an object that was created by `getProfiles()`. The user must also provide the `parameter` of interest. If the user is uncertain about what parameter exists within a certain float, `argoFloats` will prompt the user with the appropriate parameters. 

An example of how to get the QC plot for oxygen, or "DOXY" is as follows:

```{r, message=FALSE, warning=FALSE, error=FALSE}
library(argoFloats)
ais <- getIndex(filename = 'synthetic', age=0)
sub <- subset(ais, ID='2902123')
lonRect <- c(56, 66)
latRect <- c(11,12)
s <- subset(sub, rectangle=list(longitude=lonRect, latitude=latRect))
profiles <- getProfiles(s)
argos <- readProfiles(profiles)
plot(argos, which='QC', parameter='oxygen')
```

*Exercise One:* Use the previous code to determine the QC of temperature for float number 4900845. Explain the results.

## showQCTests()
The `showQCTests()` is a newly added function. It's purpose is to use integer values from the [hexToNibble()] function to internally convert hex digits. In this contenxt, the hex digits come from `HISTORY_QCTEST` of a single argoFloats object that was created by [readProfiles()]. The `showQCTests()` is then used to indicate which QC tests were performed and/or failed.

An example of the `showQCTests()` used on a float near the Arabian Sea is as follows:

```{r, message=FALSE, error=FALSE, warning=FALSE}
library(argoFloats)
data('index')
subset <- subset(index, 1)
profiles <- getProfiles(subset)
argos <- readProfiles(profiles)
argos1 <- argos[[1]]
showQCTests(argos[[1]])
```

*Exercise Two*: Use the first float from ID 4900845 in exercise one,to determine which tests were performed and/or failed during quality control testing.

## applyQC()

The `applyQC()` function examines quality-control (QC) within an argoFloats obect that was reated by `readProfiles(). By default, it replaced all suspecious data with NA values, so they will not apepar in plots or be considered in calculations. This is an important early step in processing, because suspicious Argo floats commonly report data that are suspicious based on statistical and physical measures as illustrated below in the example:

```{r, message=FALSE, error=FALSE, warning=FALSE}
library(argoFloats)
# Contrast TS diagrams for raw and flag-handled data
data(index)
i <- subset(index, 1:5) # first 5 profiles
raw <- readProfiles(getProfiles(i))
clean <- applyQC(raw)
par(mfrow=c(1, 2))
plot(raw, which="TS")
plot(clean, which="TS")
```

# Adjusted Data
FIXME:: ADD CLARIFICATION FROM ARGO MANUAL ABOUT ADJUSTED DATA

## useAdjusted()

Variables with original names indicating in the string <PARAM>_ADJUSTED are assigned nicknames names ending in Adjusted by readProfiles(), so that e.g. DOXY_ADJUSTED gets the nickname oxygenAdjusted, while DOXY gets the nickname oxygen. `useAdjusted()` switches these, renaming the adjusted values, so that e.g. DOXY_ADJUSTED gets nickname oxygen and DOXY gets nickname oxygenUnadjusted. This is carried out for all data families, and also for the corresponding units and quality-control flags.

An example of the significance of adjusted vs unadjusted can be shown below:

```{r, warning=FALSE, error=FALSE, message=FALSE}
library(argoFloats)
# Plot raw and adjusted oxygen for a sample dataset
raw <- readProfiles(system.file("extdata", "SD5903586_001.nc", package="argoFloats"))
adj <- useAdjusted(raw)
par(mfrow=c(1, 2))
oce::plotProfile(oce::as.ctd(raw[[1]]), xtype="oxygen")
mtext("Raw data", side=3, line=-1, col=2)
oce::plotProfile(oce::as.ctd(adj[[1]]), xtype="oxygen")
mtext("Adjusted data", side=3, line=-1, col=2)
```

# Answers
*Exercise One:* Use the previous code to determine the quality control of temperature for float number 4900845. Explain the results.
```
library(argoFloats)
ais <- getIndex(filename = 'synthetic', age=0)
sub <- subset(ais, ID='4900845')
profiles <- getProfiles(sub)
argos <- readProfiles(profiles)
plot(argos, which='QC', parameter='temperature')
```

The results show 100% of the temperature data are considered 'good' data. This is a result of all of the files being 'delayed' mode indicating the argo profiles have undergone scrutinized testing.

*Exercise Two*: Use the first float from ID 4900845 in exercise one,to determine which tests were performed and/or failed during quality control testing.

FIX ME::: REVISIT THIS
```
ais <- getIndex(filename = 'synthetic', age=0)
sub <- subset(ais, ID='4900845')
profiles <- getProfiles(sub)
argos <- readProfiles(profiles)
a1 <- argos[[1]]
showQCTests(a1)
```

# References
[1] Carval, Thierry, Bob Keeley, Yasushi Takatsuki, Takashi Yoshida, Stephen Loch, Claudia Schmid, Roger Goldsmith et al. "Argo User's Manual, Version 3.2. December 29th 2015.[SUPERSEDED]." (2015).
